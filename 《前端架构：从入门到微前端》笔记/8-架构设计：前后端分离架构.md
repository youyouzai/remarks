### 一、前后端分离
前后端分离，即前后端各自作为一个半自治的技术独立团队，协作开发同一业务功能。
#### 1. 为什么选择前后端分离
前后端分离的原因是多种多样的，移动优先(Mobile First)战略将单页面应用带到了移动领域，使得后端需要提供RESTful风格的API,也进一步加剧了前后端分离；并且，知识的专业化使得传统的后端工程师，已经无法满足前端开发的要求。

**缺点：**  要面临API管理带来的挑战。

**优点：**
* 独立部署。前端应用可以独立运行在自己的服务器上，而不受后端上线计划的影响。
* 分清职责。后端将视图层（View)从系统架构中拆分出去，使系统变得更加简洁。
* 技术栈独立。分离之前，技术选型受一定限制，如模板引擎等。分离之后，只要保证API是一致的，前后端之间就会互不影响。
* 方便系统演进。后端可以迁移到微服务，前端可以迁移到微前端架构。
* 提高效率（相对的）。对于复杂项目而言，拆分可以降低维护成本；而对于简单的项目而言，拆分则会提高维护成本。
#### 2. 前后端分离的开发模式
瀑布模式的前后端分离，是预先制定API的文档，再进行联调。敏捷模式的前后端分离，则是一个业务一个API，每个API单独集成。
#### 3. 前后端分离的API设计
**RESTful API**几乎是前后端分离的标准实践。

相关的基本规范：
* 标准的HTTP动词（又称为HTTP请求方法）。GET/PUT/POST/DELETE/PATCH等。
* 状态码。20x/40x/50x等常见的状态码。
* 资源路径。URL用于代表资源，应该确保资源能遵循相关的规范。
* 参数处理。GET/POST。

与**API和安全**相关的要素：
* Token管理。后端处于安全考虑，会有各种复杂的管理机制。常用的有超过时间跨度则过期、二次登陆失效、多个客户端可以同时登录、Token永不过期等。而对于前端来说，只是在遇到401未授权的时候进行相应的逻辑处理。
* 表单校验。所有的表单校验都是需要前端和后端都校验的。前端校验是出于用户体验的目的，后端进行校验时默认前端是不可信的。
* 权限管理。前端往往只是根据相关的角色和权限来展示现在的页面，至于权限则要在后端进行判断。

**降低API修改带来的Bug**的几种方式：
* 统一API接口服务。将领域相关的、同一类型的API请求集成到一个服务之下。
* API数据模型。这里依赖于使用TypeScript编写应用的前端项目。编写API相关逻辑时，对应于后台返回的数据模型，编写一个接口(Interface)文件。
* 一致化处理方式。可以把API返回的结果数据封装为一个统一的对象。
* 可选的模型适配层。从后端返回的数据中取回需要的数据，并赋予新的变量名称。

### 二、API管理模式：API文档管理方式
#### 1. 传统方式
在没有专业的API工具之前，API文档都是手写的。比如Word/README.md。
* 口头约定。口头约定API是最不靠谱的方式。
* 离线API文档。采用Word文档来传递API文档。
* 在线协作API文档。比如Google Docs/Wiki.
* 版本化API文档。利用Git进行文档代码化。
* 代码即文档。在代码编写函数和功能的同时，也编写应用相应的文档。然后通过如Javadoc/JSdoc等来生成应用的相应文档。

#### 2. 互联网模式
通过一份可运行的代码，在后端不可用时，提供可供前端使用的API。代码化的方式如下：
* HTTP服务即API文档。API文档并不是必须的，可运行的HTTP服务才是最重要的。前端开发人员可以去创建一个Mock Server，即HTTP服务，来逐一模拟API接口。这种HTTP服务的形式比较简单，通常由一个个JSON文件构成。
* 代码生成可交互的API文档。可以提供一个可编辑的在线工具如Swagger，它以代码的方式保存API，还能提供生成HTTP服务的功能。

### 三、前后端并行开发：Mock Server
Mock Server(仿造服务器)，即用于仿造后端接口的模拟HTTP服务器。它是一个简单的HTTP服务，在后端未准备好的情况下，它可以为前端提供一个可用的API服务。

根据模仿后台API的程度不同，划分了不同的模仿精度：
* 低。只用于前端显示相关的逻辑，即只返回某个API相关的字段。
* 中。带权限相关的功能，需要在使用时，进行权限验证。
* 高。 除了上述的功能，还需要做出更高级的响应，如二次请求结果不一样。
#### 1、 普通Mock Server：HTTP服务器
普通的Mock Server看上去就像是一个简单的HTTP文件服务器。如Nodejs中的Mock Server 框架json-server。

#### 2、DSL形式的Mock Server
最大的特点是用配置代替代码。比如Moco,一个使用Java语言编写的简易Mock Server服务器。
下面是一个带Token认证的API相关示例：
```
[{
    "request": {
        "method": "post",
        "url": "/verify-token",
        "headers": {
            "authorization": "Bear 777777"
        }
    },
    "response": {
        "status": 200,
        "text": "{\"success\": true}"
    }
}]

// 启动服务：java -jar moco-runner-0.12.0-standalone.jar http -p 12306 -g config.json
```

当我们不带Token或者带不正确的Token，那么就会和正常的API一样返回错误。
```
$ curl -X POST -H http://localhost:12306/verify-token

> HTTP/1.1 400 Bad Request
> content-length: 0
```
#### 3. 编程型Mock Server
编程型Mock Server能提供最大化的定制功能。

一旦涉及编程，就会选择一门语言，而前端使用的是JavaScript, 后端语言是多种多样的。如果我们选择了一门编程型的DSL，那么就需要选定维护的主力——到底是前端还是后端？

编程型Mock Server更具有灵活性，但上手成本高。

#### 4. Mock Server选型指南
* 如果只是前端开发人员用来简化开发，而后端不提供支持，那么使用普通的JSON Mock Server就可以。
* 如果前后端同时维护Mock Server, 那么可以尝试使用DSL形式的Mock Server，可以提供更多的特性。
* 需要更多的定制化功能，则可以使用编程型Mock Server。

#### 5. Mock Servr的测试：契约测试
契约测试，又称为消费者驱动的契约测试(Consumer-Driver Contracts，简称CDC),是指从消费者业务实现的角度出发，驱动出契约，再基于契约对提供者进行验证的一种测试方式。

契约是一个高级版的Mock Server。两者的区别在于，契约是双方或多方共同协议的，而Mock Server则更多是从使用方的角度来考虑的。

各端以自己的方式，验证契约是否符合自身要求。可能的情况如下：
* 校验所有的字段名和返回结果是否一致
* 只校验所有的字段名是否一致
* 校验部分字段名和返回结果是否一致
* 只校验部分字段名是否一致
* 是否检验所有可能的返回结果？如在A、B、C等条件下，是否都测试？

校验所有的字段，就意味着编写测试和维护代码时的复杂度会提高。校验部分的字段，则可能缺失一些重要的信息。一个折中的方案是：**校验所有的字段名、部分的返回结果是否一致。**
具体在每个项目上实践时，都各有差异，需要慎重考虑。即不要让契约测试称为累赘，又不要让它可有可无。

#### 6. 后端契约测试
其大体的测试步骤如下：
* (1) 先运行Mock Server服务
* (2) 发起对Mock Server服务的API请求，获取相应的返回数据
* (3) 判断相应的数据、字段与API中的是否一致

#### 7. 前端契约测试
前端作为契约的消费者和使用者，才是更关心契约修改的一方。可是如果后端开发人员没有对API与契约的一致性负责，那么前端的契约测试就会变成一个枷锁。因此，前端契约测试存在必要不充分条件，即存在后端的契约测试。

前端的契约测试与后端的契约测试相差无几：请求API、获取数据、校验数据。下面是一个使用Jest编写的契约测试的示例：
```
describe('#API Contract Test' () => {
    it('should return correct data', async () => {
        const data = await mockHttp.getBook('1');
        expect(data).toBeDefined()
        expect(data.entity.name).toEqual('前端架构')
    })
})
```

#### 8. 前后端并行开发总结
在有了契约和Mock Server之后，前后端的开发模式变成：
* 前后端约定契约API，并完成对应的Mock Server实现。
* 前后端根据各自的逻辑实现对应的业务代码
* 前后端编写各种契约测试，并确定API的修改能够反映到持续集成。
* 前后端进行API集成。
* 在API修改时，修正对应的API修改

### 服务于前端的后端：BFF
一个简单的共识是，如果多端都需要计算如时间转换，那么应该由后端提供。如果存在4中客户端（Android/iOS/桌面Web/移动Web)，一个功能以0.5天的实现时间来计算，那么总共需要2天。加上对应的测试和bug修复，至少要3天。而如果是服务端实现，那么加上测试，总体上只需要1.5天左右的时间。从时间上来说，由后端来实现是相当划算的。如果在这个过程中，业务需求发生了变化，那么就会产生一系列的修改成本。

#### 1. 为什么使用BFF
**BFF**,即Backends For Frontends(服务于前端的后端)，是指在服务器设计API时会考虑客户端的使用情况，在服务端根据不同的设备类型返回不同客户端所需要的结果。BFF模式不会为所有的客户端创建通用的API，而是创建多个BFF服务：一个用于Web前端，另一个用于移动客户端。

在不同的项目下，使用BFF的意图各有不同。使用BFF的目的可能是：
* 应对多端应用。对不同的客户端进行特定的业务处理；集中处理统一逻辑，降低开发成本。
* 聚合后端微服务。当一个业务的处理和展示，需要多个后端服务时，可以通过APIGateway来聚合后端服务，以加快应用响应速度。
* 代理第三方API。客户端不直接访问第三方API，而是通过BFF作为中介来访问第三方API。
* 遗留系统的微服务化改造。从单体架构迁移至微服务时，先通过BFF来调用单体应用的功能。再逐一创建微服务，当完成一个服务时，将请求指向新的微服务。

使用BFF要考虑的因素：
* 是否需要提供多种接口，来适应不同的客户端？
* 是否需要针对某一特定客户端，进行后端接口优化
* 是否需要为第三方提供API？
* 是否存在大量的后端服务需要聚合？
* 是否需要为客户端进行业务逻辑处理？

对于快速变化的UI和业务来说，BFF是一个比较好的解决方案。它处于两端之间，能更好的响应变化。

#### 2. 对比API Gateway
API Gateway在架构上与BFF的作用类似。它是一个位于前端与后台服务之间的代理，也是后台服务的唯一入口。它将请求由客户端路由到对应的服务，并执行身份验证、监控、负载均衡等任务。比如Netflix开源的微服务网关组件Zuul，通过过滤器可以实现身份认证与安全、审查与监控、动态路由、静态相应处理、压力测试等问题。

简易的API Gateway可以是一个如Nginx/HAProxy这样的反向代理，统一前端请求的API入口，并分发到不同的服务器上。复杂的API Gateway，可以聚合后端的服务，还能根据客户端的需要返回不同的内容。

API Gateway与BFF最大的区别在于，API Gateway只拥有一个API入口，而BFF则是针对不同客户端，拥有各种API Gateway。此外，BFF会根据业务逻辑进行编码，而API Gateway只做数据的转发，不做额外的数据处理。从某种程度上来说，BFF是一种更高级的API Gateway。

#### 3. 前后端如何实现BFF
前端实现BFF和后端实现BFF的主要区别在于其所选的语言。

对于前端开发人员，由Node.js实现BFF层是第一选择。可选择合适的Web框架（如Koa/Express/Egg.js)来打造BFF，也可以用更合适的GraphQL来完成。

复杂的部分包括：
* 难以推进Node.js后端服务的使用。它可能受限于组织内部的审查和安全策略。
* 上线时，需要前端人员配合上线。在传统的上线方式里，前端只是作为静态文件来部署，可以交由后端来完成上线。
* Node.js相关的调试、内存泄漏问题的排查，需要相关的专家。

#### 4. 使用GraphQL作为BFF
GraphQL即是一种用于API的查询语言，又是一种标准，也相当于一个满足开发者数据查询的运行时。

下面是GraphQL查询一个id为2的记录的代码，功能是获取其中的id/category字段的值：
```
query make{
    make(id: "2"){
        id,
        category
    }
}
```
这个请求会发给GraphQL,而GraphQL则会按照定义的RESTDataSource向对应的后台服务请求数据，并返回结果：
```
{
    "data": {
        "make": {
            "id": "2",
            "category": "2"
        }
    }
}
```
下面是获取数据相应的代码：
```
class MakeAPI extends RESTDataSource {
    constructor() {
        super();
        this.baseUrl = "https://wwww.wandianshenme.com/api/";
    }
    async getMake(id) {
        return this.get(`make/${id}`);
    }
    async getMakes(args) {
        const data = await this.get('make', args);
        return data.results;
    }
}
```
定义数据源类相当于创建对应的数据源。在数据源中向对应的后端服务发送API请求，相当于一个高度定义的APIGateway。这也是GraphQL中编码的主要部分，它会处理前端的请求，并从对应的后端服务中获取数据。

GraphQL只定义了这种查询语言语法、语句如何执行等。GraphQL真正的实现则依赖于不同的服务端库。

GraphQL相对于常规的BFF具有下面的优势：
* 按需获取。客户端可以按自己的需要，从服务端获取已经定义好的资源和数据，而非进行与服务端BFF相关的编程。
* 代码即文档。与参数相比，GraphQL编写的查询语句更像是一份文档。它适合人类阅读。
* 易于使用的API调试工具。多数的GraphQL实现都能提供一个开发用的前端调试API界面，可以进行API请求、验证等。
* 强类型的API检查。面向前端的接口都有强类型的Schema做保证，能快速地定位问题。
* 易于版本化的API。其可以通过Schema扩展API，而REST则需要通过URI或HTTPheader等来接收版本。

对应的缺点：
* HTTP请求无法被缓存。由于所有的HTTP的请求只能在APP级别上实现缓存，即通过GraphQL客户端库来实现。
* 错误码处理不友好。GraphQL统一返回200的结果，在其中对错误信息进行包装。对于传统的HTTP客户端来说，需要额外的处理才能走到异常分支。
* 学习成本。使用GraphQL就要学习一门查询语言，同时还需要写一大堆Schema才能使用这种特定格式。从某种意义上来说，相当于学习一门数据库语言。
* 实现复杂。普通的场景下，需要开发人员编写Schema声明，手动编写Resolver来关联字段。一旦遇到复杂的场景，就会难以控制。

考虑到GraphQL是BFF的一种类型，可以采用如下几种架构方式：
* **GraphQL -> API Gateway -> 后端服务**。即我们只是将GraphQL作为系统的一个随时可替换的“装饰器”存在，它和常规的BFF一样，随时可以被新的技术替换掉，而不影响系统的整体设计。
* **GraphQL -> REST/RPC等接口的后端服务**。API Gateway和BFF做的事情有一部分是重复的，如果我们打算进一步使用GraphQL,那么就可以直接由GraphQL来对接后台服务。
* **GraphQL -> GraphQL接口的后端服务**。当从头构建基于GraphQL架构的应用时，可以尝试直接在后端服务中直接使用GraphQL来提供接口，而不是REST或者RPC等的形式。只是未来一旦不适合了，就需要重新修改接口。

与GraphQL相似的还有搜索引擎，使用搜索引擎构建BFF层是一个繁琐的过程，我们需要构建索引、设计应用程序的架构，并设计一套与搜索引擎同步的逻辑。

GraphQL API强类型特性，也非常适合模拟Mock Server的存在。结合测试框架Jest+Relay，便可以进行快照(Snapshot)测试。
