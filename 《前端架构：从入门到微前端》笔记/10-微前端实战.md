无论是对于从头开发，还是正在迁移的，这种架构的演进都需要一个实施时间。出于以下目的，我们需要快速“发布”MRV版本（最小可发布版本）的微前端架构应用：
* 架构在项目中的可行性验证
* 向领导和团队证明架构的可能性
* 增强团队对于新技术的信心。

在新的项目中，我们可以将带通用性、成本最低的应用，使用微前端架构来编写。我们所做的应该是一个最小的是错成本：
* (1) 有些问题会在第一阶段发生，可以留出空间和计划一一解决
* (2) 如果问题太多可以放弃这个方案

在我们实施的过程中会遇到一个又一个问题，这些问题会让我们考虑如何更好地完善一个微前端架构的应用。我们在团队中会听到各种声音，如“微前端并不是那么好用”，如“我们应该回到原来的方案上”。如果因为技术困难、实施困难而走向原来的架构，多少会有些遗憾；如果只是团队成员不能适应这种变化，那么还是要继续往这个方向前进。有时候我们不得不正视这样的挑战，偶尔在不舒适的区域，可以提升团队的适应能力。

### 一、遗留系统：路由分发
微服务在这个过程中做的事情是，将调用由函数调用变成了远程调用，如远程HTTP调用。

#### 1. 路由分发式前端
路由分发式微前端，即通过路由将不同的业务分发到不同的独立前端应用上。其通常可以通过**HTTP服务器的反向代理**来实现，或者通过**应用框架自带的路由**来解决。

通过路由分发式的微前端架构是采用最多、最易采用的“微前端”方案。这种方式更像是多个前端应用的耦合，我们只是将这些不同的前端应用拼凑到一起，使他们看起来更像是一个完整的整体，但是它们并不是一个整体，每次用户从A应用到B应用的时候，需要刷新一下页面。

下面是一个基于路由分发的Nginx配置示例：
```
http {
    server {
        listen     80;
        server_name www.koala.com;
        location /api/ {
            proxy_pass http://172.31.25.15:8000/api;
        }
        location /web/admin {
            proxy_pass http://172.31.25.16:8000/web/admin;
        }
        location /web/notify {
            proxy_pass http://172.31.25.17:8000/web/notify;
        }
        location / {
            proxy_pass /;
        }
    }
}
```
在这个示例中，不同页面的请求被分发到不同的服务器上。

我们在别的项目上也使用了类似的方式，其主要原因是**跨团队的协作**。

它适用于以下场景：
* 不同技术栈之间差异比较大，难以兼容、迁移、改造
* 项目不想花费大量的时间在这个系统的改造上
* 现有的系统在未来会被取代
* 系统功能已经很完善，基本不会有新需求

在满足上面场景的情况下，如果为了得到更好的用户体验，还可以采用iframe的方式来解决。

#### 2. 路由分发的测试
测试是必不可少的。
路由分发的测试主要分为两种：
* 单元测试。验证生成的跳转URI是否符合我们创建的规则。
* 集成测试。验证生成的URI，以及其最后（重定向）的地址是否符合要求。

### 二、遗留系统微前端：使用iframe作为容器
在采用iframe的时候，我们需要做两件事：
* 设计管理应用机制。加载机制指在什么情况下，我们会加载、卸载这些应用。在这个过程中，采用怎样的动画过渡，让用户看起来更加自然。
* 设计应用通信机制。


**通信机制**

直接在每个应用中创建postMessage事件去监听，对应用的侵入性太强。通过iframeEl.contentWindow去获取iframe元素的Window对象是一个更简化的做法。我们需要定义一套通信规范：事件名采用什么格式、什么时候开始监听事件、什么时候解绑监听事件等。

### 3. 微应用化
微应用化是指，在开发时应用都是以单一、微小应用的形式存在的，而在运行时则通过构建系统合并这些应用，组合成一个新的应用。

使用微应用化意味着我们只能使用唯一的一种前端框架。

一些缺点：
* 所有应用的依赖需要统一。一旦依赖版本不一致，可能会带来其他问题。
* 高度依赖于持续集成。每个子应用在提交的时候，都会重新构建出整个应用。一旦一个子应用出错，系统就会出错。

优点：实现简单、成本较低

#### 1. 微应用化的具体实现
微应用化的形式是，在构建时以单体应用的形式构建；在运行时，以应用模块的形式存在。从原理上说，只是从多个项目中复制出代码，然后合并到一个项目中。

下面是一个Angular应用的目录结构：
 
 ```
 |—— app
    |—— app.routing.moudule.ts
    |—— ...
    |—— reports.module.ts
|—— dashboard
    |—— ...
    |—— dashboard.module.ts
|—— reports
    |—— ...
    |—— reports.module.ts
|—— settings
    |—— ...
    |—— settings.module.ts
 ```
 除了主的app模块，还包含了dashboard/settings/reports三个模块。在微应用化里，上述应用便是最后构建过程中的应用。在构建之前这些模块是以独立App的形式存在的。而主的App模块下的功能，则可以变成主工程。这时，一共会有四个代码仓库：
 * 主代码库。只包含一个空白的框架式代码，它是一个单独的应用，可以独立构建，构建完成则成为包含另外三个应用的完整工程。
 * dashboard应用。在构建时复制对应模块、目录的代码到主工程。
 * settings应用。同上。
 * reports应用。同上。

 这个dashboard应用是一个完整的Angular应用，可以独立地开发运行。下面是dashboard应用的主要结构：
 ```
 |—— app
    |—— app-routing.module.ts
    |—— ...
    |—— dashboard
        |—— dashboard.component.css
        |—— dashboard.component.html
        |—— dashboard.component.spec.ts
        |—— dashboard.component.ts
        |—— dashboard.module.ts
 ```

为了实现以上功能，需要做如下事情：
* (1) 设计一个合理的目录结构，以容纳不同的应用。可以根据路由或者应用名来划分应用。
* (2) 解耦模块间的依赖，使它们独立运行。可以通过懒加载来解耦。

**路由LazyLoading**，即路由懒加载、惰性加载，它是根据不同的路由来将对应的模块、组件切分成不同的代码块。当路由被访问时才加载对应模块、组件。在每个路由对应的模块里，模块本身接近于独立，构建前以独立文件夹的形式，构建后以独立代码的形式存在。

当前的主流框架如Angular/React/Vue是可以支持的。路由LazyLoading依赖的是webpack对于chunk的支持。下面是一个AngularLazyLoading的示例：
```
export const ROUTES: Routes = [
    { path: '', pathMatch: 'full', redirectTo: '' },
    { path: 'dashboard', loadChildren: 'dashboard/dashboard.module#DashboardModule},
    { ... }
]
```
这些模块以相对依赖的方式导入项目，当用户单击/dashboard时，就会寻找dashboard对应的模块。应用在构建的时候会将module独立构建成*.chunk.js。这些chunk文件只在对应的路由被触发时，才会加载进来并渲染相应的模块。

这种懒加载模式意味着：
* 不需要依赖于其他模块就可以构建出应用。
* 可以更新主工程的依赖模块，而不影响系统的整体构建。

#### 2. 架构实施
这种架构模式并不复杂，实施也相对比较简单：
* 持续集成设计。
* 设计占位方式。

**持续集成设计**

其持续集成的触发机制可以由这几部分构成：
* (1) 子应用代码更新，触发对应的模块的持续构建
* (2) 主应用代码更新，触发整个系统的持续构建
* (3) 一旦步骤(1)集成成功，就会触发整个系统的持续构建。

一旦多个项目同时提交代码，就会出现一些问题，整个系统的构建可能会不断地触发。所以不得不考虑将这个应用变成手动构建，或者按时间间隔来构建，如每30分钟构建一次。

此外，为了实现在持续集成服务器上合并子应用及主应用，还需要构建脚本来执行相关的内容。它会执行如下的相关内容：
* (1) 从远程拉取最新的代码
* (2) 使用新的子应用代码代替旧的占位模块
* (3) 执行一些文本替换（可选）

**设计占位方式**

由于应用在编译的过程用依赖于这些模块，所以需要在主工程中引入一些占位模块来代替真实的模块，以避免主工程在编译的过程中出错。

这个占位模式通过以下方式来体现：
* 子应用中指向其它子应用的路由。即是否展示完整的页面，是否展示对应的空白路由页面。
* 主应用中的子应用模块。即以何种方式来展示相关的应用，是否有机制来屏蔽未实现的应用。

#### 3. 测试策略
传统的测试金字塔不能满足需求，需要添加一些额外的测试：
* 应用依赖一致性检测。
* 功能模块生成测试。

这些测试可以在一定程度上判断构建是否成功。

**应用依赖一致性检测**对于前端项目来说，从不同项目中读取配置文件package.json，然后对比其中的版本即可。

**功能模块生成测试**包含以下内容：
* 测试复制的模块能否复制到对应的目录上。
* 测试生成的模块代码大小是否正常。
* E2E测试。

对于模块是否能正确复制进行测试，最简单的方式是编写脚本，在持续集成的过程中运行测试脚本，如果没有检测到exit(-1)，则持续集成构建失败。在拥有了自动化测试之后，我们并不需要这种模式。

### 四、前端微服务化
前端微服务化是指，在不同的框架之上设计通信、加载机制，以在一个页面内加载对应的应用。我们所希望的前端微服务化是：
* 应用可以自动加载、运行，并能够与应用注册表进行联系。
* 每个应用的开发时完全隔离的，开发时互不影响。它可以接入某个框架，以更好地支持构建。

应用配置有以下适用性：
* 应用的挂载的DOM节点
* 应用的服务地址
* 应用的唯一标志
* 应用的名称
* 应用所需要加载的脚本文件
* 在加载应用时的事件绑定及应用入口
* 在卸载应用时的事件解绑

对于应用的隔离，则需要深入到不同的框架代码中了解不同框架的生命周期，才能针对性地写出每个框架的加载机制。比如Single-SPA微前端架构方案。

#### 1. 微服务化设计方案
分为两种：
* 通用型微前端方案。即可以适配不同的前端框架，更适合于迁移型的微前端项目。
* 定制型微前端方案。即只适配一种前端框架，适合于从头开发的为前端项目。

方案的选择取决于我们是否进行深度定制？如果只是保证旧系统的代码可以直接运行到新的服务上，通用型方案就能解决问题；如果还需要一系列的定制，那么就要编写适合自己的架构加载方案。而定制也意味着，需要投入额外的成本进行研发。

目前都采用基座化的方式来加载其他应用。基座化方式可以支持加载不同的前端框架，以及在基座工程上绑定业务逻辑。

可以将基座分为两种模式：
* 瘦基式。其只包含框架代码，而核心的业务代码则是由基座加载过来的。
* 胖基式。前端方案相关的代码与业务逻辑代码包含在同一个代码库中。

两种模式从本质上看，区别主要在于业务逻辑是否绑定。

一个设计基座相关功能的流程图：

![image](http://github.com/itmyhome2013/readme_add_pic/raw/master/images/nongshalie.jpg)






