### 一、前端MV*原理
MVC架构的三个层次的作用：
* 表现层：提供服务、显示信息、用户请求、HTTP请求和命令行调用
* 领域层：逻辑处理，系统中真正的核心
* 数据层：与数据库、消息系统、事物管理器和其他软件包进行通信

在前端看来则是：
* Model(模型层)：用来获取、存放所有的对象数据
* View(表现层)：呈现信息给用户
* Controller(控制层)：模型和视图之间的纽带

### 二、前端MVC架构原理
原始代码
```
<button id="demo-button"></button>
<script>
var text = "hello"
var demoButton = document.getElementById('demo-button')
demoButton.innerText = text;
demoButton.addEventListener('click', {
    handleEvent: function(event) {
        event.target.innerText = "word"
    }
})
</script>
```
对应的Model层：
```
function Model() {
    this.text = "hello";
}
```
对应的Controller层：
```
function Controller(model){
    var that = this;
    this.model = model;
    this.handleEvent = function(e) {
        e.stopPropagation();
        switch(e.type){
            case "click":
                that.clickHandler(e.target);
                break;
            default:
                break;
        }
    };
    this.getModelByKey = function(modelKey){
        return that.model[modelKey];
    };
    this.clickHandler = function(target) {
        that.model.text = "word";
        target.innerText = that.getModelByKey("text");
    }
}
```
对应的View层
```
function View(controller) {
    this.controller = controller;
    this.demoButton = document.getElementById('demo-button');
    this.demoButton.innerText = controller.getModelByKey("text");
    this.demoButton.addEventListener('click', controller.handleEvent);
})
```
对应的main方法
```
function main() {
    var model = new Model();
    var controller = new Controller(model);
    var view = new View(controller);
}
```

### 三、进阶：设计双向绑定的MVC
对应的Model层
```
function Model(){
    var that = this;
    var text = "hello";
    this.listeners = [];
    
    Object.defineProperty(that, "text", {
        get: function() {
            return text
        },
        set: function() {
            text = value;
            this.notify()
        }
    })
}
Model.prototype.subscribe = function(listener) {
    this.listeners.push(listener);
}
Model.prototype.notify = function(value) {
    var that = this;
    this.listeners.forEach(function(listener) {
        listener.call(that, value);
    })
}
```
对应的View层
```
function View(controller) {
    var that = this;
    this.controller = controller;
    var elements = documents.querySelectAll('[data-tw-bind]');
    elements.forEach(function (element){
        if(element.type === 'button') {
            element.innerText = controller.getModelByKey("text");
            that.call = function(data) {
                element.innerText = data.text;
            }
            element.addEventListener('click', controller.clickHandler)
        }
    })
    this.controller.model.subscribe(this);
}
```
对应的Controller层
```
function Controller(model) {
    this.clickHandler = function(target) {
        that.model.text = 'word';
    }
}
```
### 四、前端框架选型

#### 1. 选型考虑因素

* 团队成员能否快速掌握框架。
* 框架的生态是否丰富？是否拥有我们所需要的功能组件？
* 不同框架对于不同浏览器的支持程度如何？
* 框架的后期维护成本和难度怎样？项目的维护难度与其花费的时间和代码量是成正比的，即时间越长、代码量越大，维护成本越高。
* 是否能以最小的代价迁移现有的应用？
* 当一个框架的API不断变化并且向下不兼容的时候，就会带来额外的维护成本

#### 2. React
React只是一个View层，它是为了优化DOM的操作而诞生。为了完成一个完整的应用，我们还需要路由库、执行单向流库、web API调用库、测试库、依赖管理库等。

适用场景：

React的思想不局限于前端领域，它还有React Native、React VR等，可以在不同的平台之上运行类React的View层。使用React Native可以编写出原生的移动应用，还可以在Web应用程序与iOS、Android应用程序之间，共享大部分业务逻辑。

阿里巴巴采用React框架的主要原因是生态，如Ant Design、Ant Design Pro及Fusion等UI组件库。如Ant Design Pro则非常适合中台前端的解决方案设计。

一些相关框架如ReactXP，可以在共享逻辑的基础上实现跨多个目标平台共享视图定义、样式和动画，进一步实现代码在原生应用与Web应用的复用。

#### 3. Angular
Angular是一个大而全的框架，它提供了开发一个完整应用的所有要素。Google还提供了一个适用于Angular框架的Material Design UI库。

Angular官方还提供了开发应用所需的脚手架，包含测试、运行服务、打包等部分。

与React相比，Angular没有官方的Web领域之外的平台方案，但是在社区拥有一些相应的框架。如用于跨平台原生应用开发的NativeScript，及用于混合应用的Ionic框架，都可以在某种程度上实现与Web平台共用逻辑。

#### 4. Vue
Vue借鉴了Angular和React的一些思想，在其基础上开发了一套更易上手的框架。

Vue对比于Angular和React框架的一个优势是，对于传统的多页面应用，直接引入vue.min.js就可以使用了。对于那些需要迁移前端框架的项目来说，他可以以一种渐近式的方式来进行，在成熟后便可作为单页面应用框架来开发前端应用框架。

Vue框架适合于需要快速上手、上线的应用，还适用于迁移传统的多页面应用。

滴滴出行选择Vue框架是看中了Vue.js在移动应用开发中的优势，并对它的未来充满信心。而在早期采用Vue框架的组织，如饿了么，已经在内部拥有大量的相关生态。

#### 5. 选型总结
如果是一个大中型的企业级应用，那么基本上会选择使用Angular。

对于移动应用项目来说，如果采用React Native，那么React在当前是一个更好的选择。

对于一个中小型项目来说，如果团队的新人比较多，并且基础较薄弱，那么Vue就很适合开发人员使用。

### 五、启动前端应用
选择好前端框架后可以进行下一步开发了：
* 寻找合适的脚手架，编写出第一个“Hello Word"
* 选择合适的UI框架，以快速开发前端页面
* 确认浏览器的支持范围，以明确测试边界
* 明确响应式设计的需求，以明确在编码的过程中支持哪些设备

#### 1. 创建应用脚手架

脚手架需要做的事情：
* 通用的业务相关模块，比如登录、授权、Token管理
* 页面模板页， 如首页
* 业务模板，比如中后台应用模板
* 持续部署脚本， 比如持续集成、部署脚本
* 常用的依赖，比如UI组件库

应用脚手架并非一次编写就完事，而是需要持续不断地优化，特别是及时地跟进依赖的版本。

#### 2. 构建组件库
选择组件库需要考虑的因素：
* 是否需要跨框架的组件库，既可以支持React、Angular、Vue等不同的框架？
* 组件库是否容易替换？如果替换难度比较大，需要考虑是否进行二次封装。

创建组件库的步骤如下：
* 寻找一个现成的组件库
* 构建出组件库的基础设施。从步骤(1)的组件库中删除所有的组件，修改项目名等。
* 编写一两个测试组件，引入项目中进行测试。
* 持续不断地更新组件库

#### 3. 考虑浏览器的支持范围

Angular/Vue/React只支持IE9+的浏览器。

**JavaScript兼容(polyfill)**，为了让不同浏览器“平衡”地运行JavaScript新特性、API,需要添加一些额外的与兼容相关的JavaScript代码，这些代码就是polyfill。

Polyfill可以理解为“腻子”，就是装修的时候，可以把缺损的地方填充抹平。

通过polyfill只能解决缺少API的问题，而使用一些新的语法特性，比如箭头函数时，则需要使用转译的方法。

**转译(Transpiling)**，即通过使用Babel等编译器，来将代码编译成ES5版本的JavaScript代码。将新API、新特性都进行转译，以实现对旧式浏览器的支持。

**响应式支持**，在多数情况下，响应式设计考虑的是在不同分辨率下能正常显示，另外一个重点则是在不同分辨率下以不同的方式来展示。后者考验的是产品经理、业务分析师的设计能力，而前者则是考验开发人员。

**分辨率适配**，针对不同的屏幕大小展示不同的内容，只需要结合媒体查询(Media Queries)及JavaScript就可以实现。
```
@media (min-width: 768px) and (max-width: 1024px) and (orientation: landscape) {
    // CSS
}
```
如下是PC端常见的分辨率：
* 1280 * 768 像素
* 1366 * 768 像素
* 1440 * 768 像素
* 1920 * 1090 像素
* 2560 * 1440 像素

对于移动端来说，可以采用如腾讯移动分析提供的与设备分辨率相关的额数据。移动端主要以Android和iOS为主。Android的主要的分辨率如下：
* 1920 * 1080 像素
* 1280 * 720 像素
* 1820 * 1080 像素
* 2280 * 1080 像素 
* ...

根据不同的分辨率，可以实施相应的响应式支持：
* 保证显示器在上述的分辨率上能正确显示
* 在特定的显示器上显示特定的内容

**移动设备适配**, 设备的响应式适配是指对特定设备进行设备特定的UI展示。常见的这类应用如混合应用、移动Web应用、PWA应用等。在Android、iOS拥有不同的UI设计规范，就需要采用不同的UI方案。

### 六、服务端渲染

在没有前后端分离的时期，服务器渲染是默认提供的——由后端将数据渲染到模板上，当用户、爬虫访问时，直接返回这些HTML。

这样可以达到两个目的：
* SEO（搜索引擎优化）
* 更快的内容到达速度。直接由服务端返回HTML，会比由客户端加载到JavaScript后渲染出页面更快。

单页面应用的服务器渲染可以分为三种类型：
* 非JavaScript语言的同构渲染
* 基于JavaScript语言的同构渲染
* 预渲染

#### 1. 非JavaScript语言的同构渲染
同构渲染，即前后端共享模板文件，有各自的模板引擎结合数据来渲染出页面。

有两个步骤比较麻烦：寻找合适的渲染引擎， 手动地将状态同步给前端。

以Mustache模板引擎为例，由Controller去获取对应的Model, 再渲染出页面。多数时候搜索引擎都是依据站点地图（Sitemap)来进行索引的，所以后台就可以处理这些请求。同样的当用户访问相应的页面的时候，也返回同样的页面内容，当完成页面渲染的时候，就交由前端框架来处理相应的逻辑。

这时候它从一个多页面应用变成了一个单页面应用，如：
* 当用户搜索引擎或URL直接访问article/1232时，将直接由后端返回HTML
* 当用户从该文件跳转到别的页面时，则由前端来渲染页面，不需要经过后端处理。 ~~（没弄明白前端怎么渲染其它页面的）~~
* 当用户刷新页面时，重新由后端返回渲染好的HTML，再由前端来处理。

这种渲染方式的优势是，不需要修改现有的后端技术栈就可以直接使用，缺点是需要手动地将后端的状态同步给前端。~~（怎么同步？）~~

#### 2. 基于JavaScript语言的同构渲染
与前者相比，基于JavaScript语言的同构渲染，更容易将后端的状态提供给前端。这些状态都可以直接在同一个代码中处理，如果是非JavaScript语言的同构渲染，那么我们需要在后端语言中保持状态，又在JavaScript中处理状态。这是一个反复切换代码库的修改过程，往往容易出错——因为我们可能忘记去添加对新的状态的处理，或者在后端中提供了新的状态。~~（这里面的“状态”到底是指啥？）~~

几乎所有的主流框架都支持基于JavaScript语言的同构渲染。如React和Vue都提供了renderToString的支持，Angular框架则是使用renderModuleFactory。下面是Vue.js官网的示例：
```
const Vue = require('vue');
const server = require('express')()
const renderer = require('vue-server-renderer').createRenderer()

server.get('*', (req, res) => {
    const app = new Vue({
        template: `<div>访问的URL是：{{url}}</div>`,
        data: {
            url: req.url
        }
    })
    renderer.renderToString(app, (err, html) => {
        if(err) {
            res.status(500).end('Internal Server Error')
            return
        }
        res.end(`
            <!DOCTYPE html>
            <html lang="en">
                <head>
                    <title>Document</title>
                </head>
                <body>$ html}</body>
            </html>
        `)
    })
})
server.listen(8080)
```
这种渲染方式存在一定的问题：
* 服务端内存溢出的风险
* 组件及模块需要兼容浏览器和后端Node.js环境
* 提供状态的获取机制

#### 3. 预渲染
预渲染(PreRender)指的是预先渲染HTML，并针对爬虫返回特定的HTML。这种类型的渲染方式并不常见，一方面是因为不适合数据量大的应用，另一方面是更新比较麻烦。

有如下方法可以尝试：
* 爬虫生成静态页面。在本地运行应用，用爬虫抓取所有页面，再上传到文件存储服务器即可。
* 程序生成静态页面。在本地运行应用，内部带有真实的线上数据，由PhantomJS/Chrome Headless来渲染页面，再保存为对应的页面。
* 静态站点生成器。编写一个独立的应用程序，该应用程序将从服务器获取数据，再通过模板来渲染出静态页面。

这些方式都存在以下限制：
* 运行时，需要获取真实的线上数据
* 数据发生更新时，需要重新渲染一遍HTML

还需要考虑额外的问题：
* 生成速度。大量的数据生成的时间往往较长，从几小时到几天不等。
* 数据的实时性。如果产品数据每天都大量地更新，那么就需要每天定时地生成HTML。

Google有时候会模拟成真实的用户，不带有爬虫的那些参数和标志，去访问页面。如果我们返回给Google的两个页面差异太大——可能是忘记更新了，那么Google可能就会认为该网站作弊。

如果是一个页面数据有限的应用程序，那么这种方式也是一个快速的、便捷的解决方案——它不需要占用大量的服务器资源。