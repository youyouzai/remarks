每个架构都有各自的特色：
* 更新，让旧的应用的依赖和环境不断更新，以免成为一个不可维护的遗留系统。
* 迁移，在改变小量代码的情况下，让旧的应用可以运行在新的架构上。
* 重构，对于架构的重构，往往从模块、服务级别上对应用进行代码改善。
* 重写，对系统中的部分功能、应用或全部功能，使用新的技术栈、语言进行重写。
* 重新架构，从架构的层面上，对应用进行重新设计、拆分。

### 一、更新
在修改应用的过程中需要不断地维护，以防止这个应用变成一个遗留的、难以维护的系统。在不同的升级方式里，会面临如下挑战：
* 依赖升级。第三方依赖更新频率会比较高，且数量比较多，其更新对系统影响比较小。
* 框架升级。核心的框架部分则变动略大，在进行大的版本升级时，需要评估升级难度。
* 语言升级。往往几年才更新一个版本，在多数情况下，升级起来并不容易。

#### 1. 依赖和框架版本升级
成熟的框架、组件、库，往往采用语义化版本的形式来发布。其遵循的版本号格式是：主版本号.次版本号.修订号。如1.2.3.

其版本号的递增规则如下：
* 主版本号。当你做了不兼容的API修改。
* 次版本号。当你做了向下兼容的功能性递增。
* 修订号。当你做了向下兼容的问题修正。

采取的应对措施如下：
* 当修订号发生变更时，通常只是进行一些Bug的修复，不需要我们做出相应。
* 当次版本号发生变更时，往往可能会发生一些API变更，要视向下兼容情况来决定是否跟进。
* 当主版本号变化时，可能有些API已经不存在了，需要大量地改动应用。

在这个过程中，还会遇到依赖树(上下游依赖)冲突的问题。对于Angular这样大而全的框架，基本不存在这样的问题。但是React这种由多个组件组合而成的框架，则经常会遇到这类问题。

对一个项目采取维护模式，就需要制定一些基本的策略，比如：
* 确认合理的时间间隔，如三个月一次。
* 定期检查依赖或者使用工具自动检测。
* 为更新预留时间及经历。
* 准备文档策略，以记录过程中遇到的问题。

难点不在于规范和策略的制定，而在于升级依赖的决心。

#### 2. 语言版本升级
ES6或者TypeScript目前都没有发生严重的升级问题。其最后在浏览器上呈现的方式是一致的，都需要编译为ES5，都需要兼容当前的主流特性。

#### 3. 遗留系统重搭
如果上面两种机制都失败了，那么该应用就变成了一个遗留系统。

该应用升级可以分为如下几个步骤：
* (1) 创建全新的运行环境。
* (2) 准备接近线上环境的测试数据，如Staging。
* (3) 执行更细粒度的版本管理控制，以方便回滚。如每一次小的变更，每一个新特性的升级，都需要版本管理工具来记录。
* (4) 优先升级次要组件的版本，以方便向上兼容。
* (5) 逐一升级核心框架，以查找对应的更新日志。
* (6) 必要时自己编写依赖。在升级依赖的过程中，我们极有可能遇到的一个问题是，某个依赖不再更新，此时需要自己内联这个依赖。
* (7) 清理掉不需要的代码和文件。
* (8) 进行完整的用户验收测试。
* (9) 上线前使用线上的环境进行预部署。

还有一种粗暴的迁移方式：
* (1) 使用最新版本的依赖，创建一个新的"hello,word"。
* (2) 将旧应用的部分业务代码直接复制到新的项目中。
* (3) 修改其中不合适的代码

### 二、 迁移
迁移与重构、重写最大的不同之处在于，迁移只需要改动少量的代码，不需要深入理解代码中的业务逻辑，只是从架构、框架上略微对系统进行改造，就可以完成目标。
#### 1. 架构迁移的模式
在使用新技术迁移旧的应用之前，需要考虑以下问题：
* 旧的系统出现了什么问题？
* 拆解部分应用是否能够解决问题？
* 有没有平滑迁移的策略？
* 是否可能带来新的业务价值？
* 如何降低未来的演进风险？

迁移应用的步骤如下：
* (1) 构建和提取基础设施，如组件库、代码库。
* (2) 确认用于练手的边缘应用。如果失败了、不合适了，那么可以尝试使用其他模式。
* (3) 寻找合适的解耦方式，包含数据、事件等。
* (4) 尝试对系统的其他部分进行拆分。
* (5) 编写对应的文档及相应的培训。

#### 2. 迁移方式：微前端
迁移到微前端架构的步骤：
* (1) 寻找合适的微前端技术
* (2) 确认可行的微前端方案
* (3) 尝试使用其中的某些方案
* (4) 对比、讨论几种不同方案的利弊
* (5) 决定适合当前项目实施的方案
* (6) 尝试在一个项目中使用新架构开发
* (7) 编写架构决策记录及文档，记录实施过程中常见的问题。
* (8) 对项目成员进行相关培训

在整个过程中最复杂的部分是确认微前端方案。

#### 3. 迁移方式：寻找容器

还有一种迁移系统的方式：寻找更大的容器。
这种容器，针对浏览器的是iframe，针对移动端是App的WebView等。

iframe是当前用得比较广泛的前端容器。Web Components是一个新的组件级容器。Electron提供了用于运行的WebView容器。

### 三、重构
应用的重构是在软件开发过程中的行为，而不是维护期进行的工作。
#### 1. 架构重构
只有测试才能保证重要的重构能往下进行，否则只能大量依赖于手工测试。

引入测试的步骤如下：
* (1) 选择合适的测试框架，并引入项目中
* (2) 找到需要重构的代码，编写相应的单元测试用例
* (3) 提交相关的测试代码。
* (4) 准备进行代码重构

在没有测试的情况下，可以适当地采用IDE重构的方式，它能在有限的空间里改善代码的质量。其通常是由快捷键来触发的。

重构的流程如下：
* (1) 创建一个新的重构分支
* (2) 从简单的重构开始练习。如目录调整、重命名变量。
* (3) 小步提交。使用细致化的版本管理，方便出错后的回退管理。
* (4) 对复杂的代码进行样式拆分、逻辑拆分、组件拆分。对于函数来说，可以采取提取变量的方式进行。
* (5) 修改或者编写测试，保障业务功能正常。
* (6) 对于复杂的功能，寻找合适的人一起完成重构。

#### 2. 组件提取、函数提取、样式提取
#### 3. 引入新技术
以下几种代码的重构方式比较常见：
* 新的编程理念。比如，使用promise替换callback，或者在复杂的前端处理逻辑中，采用reactive.js或者rambda来解决问题。
* 引入新的框架特性。比如，在React中引入Redux来解决状态问题。
* 解决语言糟粕。比如，当要解决大量的浮点计算的问题时，需要引入如bignumber.js这样的库。尤其是当我们的代码中充满了各种相关的语句判断时，就需要通过这些库来重构。

### 四、重写
在拥有足够人力和物力的情况下，对于旧系统或者遗留系统而言，最好的使用方式就是重写应用。
#### 1. 重写能解决问题吗
重写怎样才能带来业务价值？下面是问题的答案：
* 更少的功能完成时间。旧的系统需要3天才能完成的功能，新的系统现在只需要1天就能完成。
* 更好的用户体验
* 提升应用的性能。旧的应用需要3秒才能响应结果，新的系统只需要0.5秒。

系统需要重写的证据：
* 过时的依赖或技术。如使用过时的前端框架，找不到合适的开发人员。
* 出现表达力更好的技术。原来需要20行代码的功能，现在只需要5行代码。
* 旧代码无法维护。难以维护和无法维护是两个概念。

重写需要考虑的因素：
* 重构、迁移、升级真的不能解决问题吗？
* 重写的时间预期是多少？重写的时间花费往往比预期更好，比技术上花费的时间更短，但清理业务的时间更长。
* 能接受重写的成本吗？重写不会对业务带来额外的好处，反而是在浪费时间。
* 是否整理出完整的功能列表？只有清晰的功能列表，才能保证重写不被阻碍。
* 产品是否领先于市场？在重写期间，我们的开发速度可能会落后于其他产品。
* 是否有能力维护两个产品和团队？在重写期间，需要在新旧应用里实现同样的功能。
* 在重写完成之前，是否可能变为遗留系统？要进行合理的技术选型，以避免重写失败。

因此，只有当 重写应用的花费 + 维护应用的花费 &lt; 维护现有系统的花费时，我们才应该考虑重写。同时在重写的过程中，还需要继续维护现有的应用。

在重写的过程中需要考虑开发人员的感受——在有些人看来，重写是浪费时间。有足够的重写热情的人，能推动重写的完成；而有遗留系统经验的人，能保证在重写的过程中少走弯路。

#### 2. 梳理业务
从技术层面上看，重写应用并不复杂，复杂的地方在于清理原有的业务逻辑——看着旧的业务代码，编写新的业务代码，找寻公司内部相关的人寻问业务。

#### 3. 沉淀新架构
如果没有一个重写的可行的方案，就需要对旧系统的架构进行总结：吸收旧系统的优点，总结旧系统的设计缺陷。

新旧系统的相似之处如下：
* 选择更合适的技术栈
* 进行组件和系统的防腐设计。
* 系统与应用间的解耦设计

在过程中改进系统，而非在未来重写应用。

### 五、重新架构
讨厌重写的地方：
* 难以说服业务人员
* 重写并不是一种很好的体验——它好像只是在练习技术栈而已，不能带来技术上的成长。

与重写相比，重新对应用的架构进行设计，是一种更有意思的挑战。

#### 1. 重搭架构
重搭架构，与重构相比，是一种更高阶的应用重构。它从应用的层级上对架构进行重新设计，而非在代码层级上进行改造。

我们所要做的是细分代码库，将其拆分成多个依赖、组件、应用。核心目标是将系统变成高内聚、低耦合的系统。

#### 2. 增量改写
增量改写，即将系统拆分为多个独立模块或应用。

每次只重写应用中的一部分，直到重写完所有的模块，系统也重写完成了。这种模式，又称为绞杀者模式。它可以实现以下目标：
* 大幅度减少对于业务的影响，降低了风险。
* 可以随时停止重写，而不影响用户的使用。
* 用户、客户可以随时看到网站的变化，带来更多的价值。
* 为开发人员带来更多的自由和乐趣
* 每个模块重写时，只关心相关部分的业务，而非所有的业务。

该拆分方式仍依赖于微架构。对于后端来说，往往是使用BFF作为防腐层。对于前端来说，需要使用微前端架构来拆分现有的前端应用。它和我们前面所讲的内容是相似的：
* 设计全新的路由分发机制
* 使用新技术编写某一部分的应用
* 将路由指向新的前端应用，剩下的部分仍然指向旧的应用
* 不断添加新功能、重写模块，直至完成重写。