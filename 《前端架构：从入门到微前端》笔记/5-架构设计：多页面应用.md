尽管单页面应用很流行，但是我们并不总是需要它。在学习编程的初级阶段里，经常会掉入一个陷阱：一旦学会一个新的框架，就会在我们的大部分项目中使用这个框架。即所谓的“锤子定律”：
```
我认为，假设你拥有的工具只有一个锤子时，你把所有的事物当作钉子来对待是很有吸引力的。
```
### 为什么不需要单页面应用
单纯从技术上考虑，会得到这样一些结论：
* 构建单页面应用的成本很高
* 前端生态快速发展，学习成本很高
* 单页面应用对SEO（搜索引擎优化）并不友好
* 应用架构更加复杂

有意思的是，从非技术的角度来讲，比如KPI/技术远景，使用单页面应用才是最合适的。
#### 1. 构建成本
当应用是一个报名表单时，需要如下步骤：
* (1) 编写页面样式，以提供更好的页面效果
* (2) 动态获取数据，以渲染下拉菜单供用户选择
* (3) 在用户提交前，实施对应的表单验证，以提供更好的用户体验

在使用传统的前端技术中，我们只需要找到一个表单插件，添加到代码中，编写一些相应的代码就可以了。
#### 2. 学习成本
#### 3. 后台渲染成本
面向Google的网站，可以提供更好的JavaScript渲染支持，而国内的百度、搜狗等搜索引擎，对Javascript渲染页面的支持并不是很好。
如果网站的主要流量来源是搜索引擎，那么我们就不可能放弃这些“免费”的流量，我们的应用就需要支持爬虫，此时我们就要尽可能地提供一份由HTML构成的内容。
如果是单页面应用，就要使用额外的方式支持：
* 预渲染，即面向搜索引擎提供一份可以被索引的HTML代码
* 同构应用，有后端运行JavaScript代码生成对应的HTML代码
* 混合式后台渲染，由后端解析前端模板，生成对应的HTML代码
#### 4. 应用架构的复杂性
架构方式变成了前后端分离架构。
### 简单多页面应用开发
多页面应用往往是一些轻量级的前端应用，多数时候会被划定为“前端页面”。常见的这一类应用有：
* 门户类、资讯类、数据展示类应用，比如博客、CMS系统，等等。
* 弱交互型应用，比如GitHub/Gitlab这样的代码管理站点，就不需要太多交互
* 面向资源受限的设备应用，嵌入式系统由于资源限制，往往运行的不是完整的JavaScript引擎，会导致难以支持完整的单页面应用。
#### 1. 选择UI库及框架
#### 2. Jquery和Bootstrap依然好用
#### 3. 不使用框架：You Don't Need XXX
对于那些只是简单的显示、隐藏DOM等操作的应用来说，我们完全不需要任何框架。
### 复杂多页面应用的开发
我们选择MVC框架，多数是因为我们需要其中的一些特性：
* 模板引擎，动态生成、创建页面
* 双向绑定，实时修改数据
* 前端路由，路由变化映射到对应的逻辑上
** 等等
正是这些特性组成了一个前端框架。
#### 1. 模板与模板引擎原理
模板引擎，又可以称为模板处理器，它是一个结合模板和数据模型来输出最终文件的处理程序。在前端领域里，这种文档是HTML.
前端模板引擎分为两种：基于字符串的模板应请和基于JavaScript的模板引擎。
#### 2. 基于字符串的模板引擎
就是通过字符串替换的方式，来渲染出HTML,再将HTML插入DOM节点中，其代表性框架有Mustache.js和Handlebars.js。
其基本原理是，全局正则匹配模板关键字，如{% name %}, 再从传入的data中找到是否有对应的值，如data中存在name的对象，则使用该值进行替换，否则该值为空。
基于字符串的模板引擎在更新DOM的时候会更新所有DOM节点，浏览器需要渲染所有的节点。当进行大量的DOM操作时，每次都刷新整个DOM节点，显然是不合适的。这时需要更高级一点的方案。
#### 3. 基于JavaScript的模板引擎设计
其表现形式是，将模板定义为JavaScript,在执行的过程中，再动态更新所需要的DOM节点。相应的逻辑如下：
* (1) 将模板编译成某种DSL(领域特别语言)，比如HyperScript或者JavaScript对象（代码 + 数据）
* (2) 在使用时，调用JavaScript来渲染DOM结点
* (3) （可选）当发生变更时，通过DOM Diff算法来替换对应的修改节点。
与基于字符串的模板引擎的主要区别在于第3点：是否全局替换DOM节点。在进行大量DOM操作的时候，由于只对变化的DOM进行替换，可以提高前端应用的性能。
基于Virtual DOM技术的JavaScript模板引擎的基本逻辑如下：
* (1) 使用一种名为HyperScript的DSL（领域特定语言）来创建虚拟的树
* (2) 通过这个虚拟树来创建一个DOM节点
* (3) 在数据发生变化的时候，diff DOM节点会发生变化，并通过更新修改对应的DOM来更新模板
HyperScript是一个用于创建HTML结构的Script脚本的工具，可以用于渲染出一个虚拟的DOM树。示例为
```
h('a', {href: 'http://google.com'}, 'aofe')
// h是hyperscript的缩写
```
在使用Virtual DOM的前端框架时，通常使用类XML（HTML也是类XML）的形式来编写模板，比如React的模板代码如下：
```
class ShoppingList extends React.Component {
    render() {
        return (
            <div className="shopping-list">
                <h1>Shopping List</h1>
                <ul>
                    <li>Instagram</li>
                    <li>WhatsApp</li>
                </ul>
            </div>
        )
    }
}
```
再将这个模板转换为中间DSL状态：
```
return React.createElement('div', {className: 'shopping-list'}),
React.createElement('h1', /* ... h1 children ... */),
React.createElement('ul', /* ... ul children ... */),
```
#### 4. 双向绑定原理及实践
双向绑定，即双向数据绑定，它是指视图(View)的变化能实时的让数据模型(Model)发生变化，而数据的变化也能实时更新到视图层。
双向绑定有几种不同的实现方式：
* 手动绑定。即两个单向绑定的结合，通过手动set和get数据来触发UI或数据变化
* 脏检查机制。即发生指定的事件时（如HTTP请求、DOM事件）时，遍历数据相应的元素，然后进行数据比较，对变化的数据进行操作。
* 数据劫持。即通过hack方式（Object.defineProperty）对数据的setter和getter进行劫持。在数据变化时，通知相应的数据订阅者，以触发相应的监听回调。
### 前端路由原理及实践
路由是前端应用的一个核心功能，它用于连接分散在各处的控制逻辑。
#### 1. 两种路由类型
**基于History API的路由**和传统路由基本一样，区别是它可以通过JavaScript来控制。
HTML5中的History API 无刷新更改地址栏链接，配合Ajax可以做到无刷新跳转。
其基本方法：
* back, 返回前一页
* forward, 在浏览器记录中前往下一页
* go, 在当前页面的相对位置从浏览器历史记录加载也
* pushState, 按指定的名称和URL将数据push进会话历史栈
* replaceState, 指定的数据、名称和URL，更新历史栈上最新的入口
History API是基于真实的URL操作的，如果没有配置好相应的HTTP服务器，刷新页面的时候是找不到对应页面的
**基于Hash的路由**在浏览器地址栏是通过#号及后面的部分来代表URL的。其原理：location.href会获取当前页面的URL,而location.hash将会获取#后面的内容。如URL是https://www.renwoxing.com/#test=true，那么location.hash获取的值为#test=true。当一个窗口的hash改变时就会触发windows的hashchange事件。监听该事件，绑定路由与函数的映射关系，就可以完成一个基础的路由系统。
路由的Hash具有以下一些特点：
* Hash值得改变不会导致页面重新加载
* Hash值由浏览器控制，不会发送到服务器
* Hash值得改变会记录在浏览器的访问历史中，因此可以在浏览器中前进和后退
* 访问网页中，若URL中带有Hash,页面会定位到id和Hash值一样的元素的位置
### 避免散弹式架构
```
如果每遇到一种变化，你都必须在许多不同的classes内做出许多小修改以响应之，你所面临的坏味道就是散弹式修改（Shotgun Surgery）。如果需要修改的代码散布四处，你不但很难找到它们，也和容易忘记某个重要的修改。 ————《重构》
```
#### 1. 如何降低散弹性架构的出现频率
完全避免散弹性修改几乎是不可能的，但是可以尽量降低它们的修改。
* 统一交互处理。类似于组件化的方式，可以提供一个类、函数来统一管理，也可以通过全局事件来管理。
* 按页面拆分脚本。这种方式可能是历史的一个倒退。常规的打包是将所有的JavaScript脚本打包到一个JavaScript文件中。而现在，每个页面加载独立的JavaScript，可以降低相互之间的影响。这种方式依赖于更加复杂的构建系统————需要一个共用库以及独立的页面脚本，然后才能构建出独立的脚本。
* 尽量使用ID而非class。
 
