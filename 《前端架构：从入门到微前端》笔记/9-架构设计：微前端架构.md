大型组织的组织结构、软件架构在不断地发生变化。移动优先(Mobile First)、APP平台(One App)、中台战略等，各种口号不断地被提出、修改和演进。同时，其业务也在不断地发展，由线下到线上、从无到有，这些进一步地导致组织的应用不断地膨胀，进一步地映射到软件架构上。

系统的组织在不断地变化的同时，其设计和架构也在不断地调整。
### 一、微前端
微前端是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将单页面前端应用由单一的单体应用转变为把多个小型前端应用聚合为一的应用。各个前端应用还可以独立开发、独立部署。同时，它们还可以进行并行开发——这些组件可以通过NPM、Git TagGit或者Submodule来管理。
#### 1. 微前端架构
* 应用自治。微前端架构，是多个应用组件的统一应用，这些应用可以交由多个团队来开发。要遵循统一的接口规范或者框架，以便于系统集成到一起，相互之间不存在依赖关系。
* 单一职责。微前端架构理应满足单一职责的原则。
* 技术栈无关
#### 2. 为什么需要微前端
* 遗留系统迁移。解决遗留系统，是采用微前端方案最重要的原因。
* 后端解耦，前端聚合。后端微服务可以解耦服务间的依赖，而对于前端来说，更想要的结果是聚合前端应用，尤其是ToB的应用。
* 热闹驱动开发。所谓热闹驱动开发指的是，软件开发团队所做的软件架构或技术栈的决策，其中很多决策并没有经过踏实的研究和对目标成果的认真思考，而是不准确的意见、社交媒体的信息，或者就是些“热闹”的玩意。

### 二、 前端技术的拆分
从技术实践上，微前端架构可以采用以下几种方式进行：
* (1)路由分发式。通过HTTP服务器的反向代理功能，将请求路由到对应的应用上。
* (2)前端微服务化。在不同的框架之上设计通信和加载机制，以在一个页面内加载对应的应用。
* (3)微应用。通过软件工程的方式，在部署构建环境中，把多个独立的应用组合成一个单体应用。
* (4)微件化。开发一个新的构建系统，将部分业务功能构建成一个独立的chunk代码，使用时只需要远程加载即可。
* (5) 前端容器化。将iframe作为容器来容纳其他前端应用。
* (6) 应用组件化。借助于Web Components技术，来构建跨框架的前端应用。

#### 1. 路由分发式
路由分发式前端，即通过路由将不同的业务分发到不同的独立前端应用上。其通常可以通过HTTP服务器的反向代理来实现，或者通过应用框架自带的路由来解决。

当前而言，路由分发式的架构是采用得最多、最容易的“微前端”方案。它只是将这些不同的前端应用拼凑到一起，让他们看起来像一个完整的整体。每当用户从A应用转换到B应用的时候，往往需要刷新一下页面、重新加载资源文件。

在这个架构中，我们只需要关注应用间的数据传递方式。通常，我们只需要将当前的用户状态，从A应用传递到B应用即可。如果两个应用在同一个域中，可以通过LocalStorage、Cookies、IndexedDB等方式共享数据。

在采用这种应用时，缺少了对应用状态的处理，需要用户重新登录，这种体验对用户来说相当不友好。
#### 2. 前端微服务化
前端微服务化，是微服务架构在前端的实施，每个前端应用都是完全独立（技术栈、部署、构建独立）、自主运行的，最后通过模块化的方式组合出完整的前端应用。

当我们单击指向某个应用的路由时，会加载、运行对应的应用。而原有的一个或多个应用，仍然可以在页面上保持运行的状态。这些应用可以使用不同的技术栈开发，如页面上可以同时运行React、Angular和Vue框架开发的应用。

实施的原因是基于现有的前端框架都离不开基本的HTML元素DOM。所以只需要做到以下两点：
* (1) 在页面合适的地方引入或者创建DOM
* (2) 用户操作时，加载对应的应用（触发应用的启动），并能卸载应用

同时，需要保证应用间的第三方依赖不冲突。如应用A中使用了z插件，而应用B中也使用了z插件，如果一个页面多次引入z插件会发生冲突。我们可以通过向上游开发者提Pull Request来修复这个问题。

#### 3. 组合式集成：微应用化
微应用化是指，在开发时应用都是以单一、微小应用的形式存在的，而在运行时，则通过构建系统合并这些应用，并组合成一个新的应用。

微应用化大都是以软件工程的方式来完成前端应用的开发的，因此又称之为组合式集成。

对于一个大型的前端应用来说，采用的架构方式往往是通过业务作为主目录的，然后在业务目录中放置相关的组件，同时拥有一些通用的共享模板。例如：

```
|— accout
|— dashboard
|— reports
|— ...
|— shared
```


当开发这样一个应用时，从目录结构上，业务本身已经被拆分了。我们所要做的是，让每个模块都称为一个单独的项目，如将仪表盘功能提取出来，加上共享部分的代码、应用的基本脚手架，便可以称为一个单独的应用。拆分出每个模块之后，便只需要在构建的时候复制所有的模块到一个项目中，再进行集成构建。其实就是合并代码文件，只不过这些代码文件位于不同的工程。

#### 4. 微件化
微件(Widget)，是一段可以直接嵌入应用上运行的代码，它由开发人员预先编译好，在加载时不需要再做任何修改或编译。

微前端下的微件化是指，每个业务团队编写自己的业务代码，并将编译好的代码部署到指定的服务器上。在运行时，我们只需要加载相应的业务模块即可。

在非单页面应用时代，要实现微件化方案是一件特别容易的事。从远程加载JavaScript代码并在浏览器上执行，生成对应的组件嵌入页面。

为了支持微件化，需要做下面这些事情：
* (1) 持有一个完整的框架运行时及编译环境。这用于保证微件能正常使用，即可调用框架API等。
* (2) 性能受影响。应用由提前编译变成运行时编译，会造成一些性能方面的影响
* (3) 提前规划依赖。如果一个新的微件想使用新的依赖，需要从上游编译引入。

此外，还需要一个支持上述功能的构建系统，它用于构建一个独立的微件模块。这个微件的形式如下：
* 分包构建出来的独立代码，如webpack构建出来的chunk文件
* 使用DSL的方式编写出来的组件

#### 5. 前端容器：iframe
iframe能有效地将另一个网页/单页面应用嵌入到当前页面中，两个页面间的CSS和JavaScript是相互隔离的。iframe相当于创建了一个全新的独立的宿主环境，类似于沙箱隔离，它意味着前端应用之间可以相互独立运行。

采用iframe的前提：
* 网站不需要SEO支持
* 设计相应的应用管理机制

如果我们做一个应用平台，会在系统中集成第三方系统，或多个不同部门团队下的系统，显然这依然是一个非常靠谱的方案。
#### 6. 结合Web Components构建
Web Components是一套不同的技术，允许开发者创建可重用的定制元素，并且在Web应用中使用它们。

真正在项目上使用Web Components技术，离现在的我们还有些距离，可是结合Web Components来构建前端应用，是一种面向未来演进的架构。

### 三、微前端的业务划分方式
常见的几种划分微前端的方式：
* 按照业务拆分
* 按照权限拆分
* 按照变更的频率拆分
* 按照组织结构拆分
* 跟随后端微服务拆分
#### 1. 按照业务拆分
在大型的前端应用里，往往包含了多个业务。这些业务往往在某种程度上存在一定的关联，但并非是强关联。
#### 2. 按照权限拆分
对于一个同时存在多种角色及多种不同权限的网站来说，最容易采用的方案就是通过权限来划分服务和应用。尤其这些权限在功能上是分开的，也就没有必要集中在一个前端应用中。

是否按照权限来划分应当取决于应用是否臃肿，或者是否正在变得臃肿，导致难以维护。还需要考虑是否为每种角色和权限划分不同的前端应用。
#### 3. 按照变更的频率拆分
在一个前端应用中，并非所有模块和业务代码都在不断地修改、添加新的功能。不同的业务模块拥有不同的变更频率。有些功能可能在上线之后，因为用户少而几乎不修改；有些功能则可能为了做而做，即证明有这个技术能力，或者有这个功能。而有一些功能，因为是用户最常用的，所以在不断迭代和优化中。

使用变更的频率进行拆分的前提是，我们使用数据统计来计算各部分的使用情况。

#### 4. 按照组织结构拆分
团队的组织方式必然会对它产生的代码有影响。

对于后端来说，按照组织结构拆分服务，几乎是一个默认的做法。团队之间使用API文档和契约，就可以轻松地进行协作。

作为架构的提出方和主要的核心技术团队，我们需要提供微前端的架构方案。如使用路由分发式微前端，需要提供一个URL入口：使用前端微服务化，需要提供一个API或者接入方式，以集成到系统中。

对于跨团队协作来说，集成永远都是一个复杂的问题。技术问题更适合于当面讨论，如指着代码或页面进行讨论。一旦有一方影响了系统构建，就需要优先去解决这个问题。

#### 5. 跟随后端微服务拆分
与微架构相关的实施，并不只有前端才有，往往是后端拥有相应的实施，前端项目才会进行进一步地拆分。而一旦后端拥有相关的服务，前端也可以跟随后端的拆分方式。

#### 6. DDD与事件风暴
DDD(Domain Driven Design,领域驱动设计)是一套综合软件系统分析和设计的面向对象建模方法。DDD中的一个界限上下文（Bounded Context），相当于一个微服务。而识别界限上下文的核心是，识别出领域的聚合根，这时便依赖于事件风暴来进行。

事件风暴(Event Storming)是一项团队活动，旨在通过领域事件识别出聚合根，进而划分微服务的界限上下文。事件风暴就是把所有的关键参与者都召集到一个很宽敞的屋子里来开会，并且使用便利贴来描述系统中发生的事情。

通过以下步骤确定各个业务的边界，同时划分出每个服务：
* (1) 寻找领域事件
* (2) 寻找领域命令
* (3) 寻找聚合
* (4) 划分子域和界限上下文

### 四、微前端的架构设计
微前端要和微服务一样，要进行实践，并做好一系列的技术储备。
#### 1. 构建基础设施
在微前端设计初期，要做如下事情：
* 组件与模式库。在应用之间提供通用的UI组件、共享的业务组件，以及相应的通用函数功能模块，如日期转换等。
* 应用通信机制。设计应用间的通信机制，并提供相应的底层库支持。
* 数据共享机制。对于通用的数据，采取一定的策略来缓存数据，而不是每个应用单独获取自己的数据。
* 专用的构建系统（可选）。在某些微前端实现里，如微件化，构建系统用于构建出每个单独的应用，又可以构建出最后的整个应用。

#### 2. 提取组件与模式库
模式库作为微前端架构的核心基础，可以用于共享代码。

**样式**

一个页面里同时有多个前端应用，会存在以下几种形式的样式：
* 组件级样式。有些框架可以从底层上直接支持组件模式隔离，如Angular，不需要花费精力考虑。对于组件库来说，也会创建对应的CSS前缀来保证唯一性，只要在开发的过程中多加注意即可。
* 应用级样式。需要制定一个统一的规范，可以根据应用名加前缀，如dashboard-，也可以根据路由增加相应的前缀。我们往往会为这些应用，创建一个统一的样式库，以提供一直的用户体验
* 系统级样式。只存在于基座模式设计的微前端架构里。在这种方案里，由基座应用来控制其他应用，也存在部分的样式。在编写这些样式的时候，需要注意对其他应用的影响。

**业务组件及共享库**

在多个应用中使用的业务组件和共享函数，我们可以提供NPM包的方式，又可以提供git submodule的方式，引入其他应用中。

对于通用的组件，它在开发的前期需要频繁地改动，这时可以抽取成为子模块(Submodule)的形式在项目中使用。当这些组件趋于稳定的时候，可以尝试作为NPM包发布。

这种类型的修改应当是兼容式的修改。在难以兼容的情况下，需要对系统中使用到的部分，逐一进行排查，直到确认已更新下游API。还要进行相应部分的测试，以确保组件修改带来的影响都已经被修复。

#### 3. 应用通信机制
从应用关系来看，存在两种类型的通信：
* 同级通信，即挂载在同一个HTML Document下的应用间的通信
* 父子级通信，及采用iframe形式来加载其他应用。

**同级通信**通过全局的自定义事件便可以实现，可以开发自己的发布-订阅模式组件。

普通的**父子级通信**可以做到以下几点：
* 通过PostMessage在父子窗口之间进行通信
* 通过parent.window寻找到父窗口，由父窗口发出自定义事件。
* 当其他应用未加载时，先将消息传递给父窗口，再由父窗口进行存储，提供一个获取通信的机制。

在实现的过程中，往往会出现两种结果：
* 嵌入业务的特定通信机制。它是一个业务绑定的模式，一旦添加新功能，便需要进行修改。
* 剥离业务的通用通信机制。它是一个通用的通信机制，开发成本相对较高。

#### 4. 数据管理
单页面应用是指对于业务状态的管理与处理。

前端与后端进行交互时，需要传递大量的状态。状态有两部分组成：URI(GET的传递参数会转换到URI中)+请求body。

应用的数据管理可以分为两部分：状态和应用数据。状态是一种特殊的应用数据，它更加显示地展示数据。

通过上部分的应用通信机制，可以解决部分数据共享的问题。通用部分的数据，则可以选择一个合适的数据管理策略。为此，我们需要一个去中心化的管理数据，或者基于基座应用的数据管理机制。

常见的数据交互方式，有以下几种：
* URI参数传递
* 使用LocalStorage共享数据
* 其他客户端存储，如IndexDB/Web SQL等
* 服务端存储客户端状态，可以采用JSON格式存储。

我们很难通过一套有效的方案来管理，往往是通过规范来保持一致。如在某些情况下使用URI传递参数，在某些情况下应用自身从LocalStorage获取。同时，还需要集合安全存储策略。

#### 5. 专用的构建系统
只有那些依赖于构建及构建工具创建出来的前端应用，才需要设计出一个专用的构建系统，以支撑系统的开发。

如果我们采用了微应用化、微件化的架构方案，就需要设计自己的构建流程、构建系统。微件化需要修改构建工具，如添加对应的构建插件，是它能支持构建出组件包。微应用化则依赖于设计构建流程，而不需要对构建工具进行修改。

### 五、微前端的架构模式
从应用关系来看分为两种模式：
* 基座模式。通过一个主应用来管理其他应用。设计难度小、方便实践，但是通用度低。
* 自组织模式。应用之间是平等的，不存在相互管理的模式。设计难度大，不方便实施，但是通用度高。

两种模式都需要提供一个查找应用的机制，在微前端中称为服务的注册表模式。这个应用注册表的服务，可以是一个固定值的配置文件，如JSON文件，或者是一个可动态更新的配置，又或者是一种动态地服务。类比于微服务的Eureka。它主要做以下事情：
* 应用发现。让主应用可以寻找到其他应用。
* 应用注册。即提供新的微前端应用，向应用注册表注册的功能。
* 第三方应用注册。即让第三方应用接入系统中
* 访问权限等相关配置。

#### 1. 基座模式
基座承担了微前端应用的基础与技术核心。基座模式，是由一个主应用和一系列业务子应用构成的系统，并由这个主应用来管理其他子应用，包括从子应用的生命周期管理到应用间的通信机制。

基座模式中的主应用，类似于API Gateway的概念，它作为系统的统一入口，负责将对应的请求指向对应的服务。子应用，则是负责各个子模块的业务实现。

主应用即可以只带有单纯的基座功能，也可以带有业务功能。它所处理的业务功能指的是核心部分的业务功能。如：
* 用户的登录、注册管理
* 系统的统一鉴权管理
* 导航菜单管理
* 路由管理
* 数据管理
* 通信代理

作为应用的基础核心，还需要：
* 维护应用注册表。在应用注册表上表明系统有多少个服务、能否找到对应的应用等。
* 管理其他子应用。如在何时加载应用、何时卸载应用等。

#### 2. 自组织模式
自组织指的是，系统内部各子系统之间能自行按照某种规则形成一定的结构或功能。采用这种模式可以使系统内的各种前端应用，都各自拥有一个小型的基座管理功能，也相当于每个应用都可以使基座。

在采用基座模式时，用户要想访问A应用需要先加载主应用，然后才能加载A应用。采用自组织模式时，用户想要访问A应用则只访问A应用，不要加载主应用。因此拥有更高的自主性。

不过多数时候，我们并不需要自组织模式的微前端架构，因为它设计起来复杂，拥有大量的重复代码。

### 六、微前端的设计概念
在设计时需要关注以下内容：
* 中心化：应用注册表
* 标志化应用
* 应用生命周期管理
* 高内聚，低耦合
#### 1. 中心化：应用注册表
以路由形式的注册表为例，当我们添加了一个新的应用时，就相当于在网页上添加了一个菜单链接，用户就能知道哪个页面时可以使用的，也就能访问到这个新的应用。

#### 2. 标志化应用
标志化应用是指，建立某种规则来区分不同的应用，类似于唯一标识符，即ID。这个ID可以在安装和卸载的时候，寻找到指定的应用。

```
系统设计、产品结构等同组织形式，每个设计系统的组织，其产生的设计等同于组织之间的沟通结构。 ——康威定律
```
对于第三方应用来说，可以添加对应的前缀，如3rd-xxx，以区分不同的应用。并且第三方应用需要向系统申请，才能接入这个系统中。

如果存在大量的不需要审核的应用，那么可以由系统后台来生成唯一的标志符。

#### 3. 生命周期
当用户单击某个链接时，相应的系统需要加载相应的应用，在这个过程中，还需要加载动画来相应用户的行为，并创建应用所需要的DOM节点，将应用挂载到相应的DOM节点上，然后运行应用。当用户不需要这个应用时，我们可以选择卸载应用，或者继续保留应用。这几个步骤所做的事情，就体现了应用的生命周期。

微前端应用作为一个客户端应用拥有自己的生命周期。包括以下3个部分：
* (1) 加载应用
* (2) 运行应用
* (3) 卸载应用

在微前端框架Single-SPA中设计了一个基本的生命周期，其包含如下5中状态：
* load：决定加载哪个应用，并绑定生命周期
* bootstrap：获取静态资源
* mount：安装应用，如创建DOM节点。
* unload：删除应用的生命周期
* unmount：卸载应用，如删除DOM节点、取消事件绑定

这部分的内容事实上就是微前端的一个难点所在，如何以合适的方式来加载应用呢？每个前端框架都各不相同，其所需要的加载方式也是不同的。

#### 4. 高内聚，低耦合
在设计各个子应用及主应用的过程中，需要遵循高内聚、低耦合的原则。

### 七、"微"害架构
在微架构的过程中出现的一些问题，它会导致架构的弊大于利。如《人月神话》所说，没有银弹。一个架构有好的一方面，实施不好则有害。

"微"害架构，即微架构以不合理的方式运行着，它采用“微架构”（微服务、App插件化、微前端等）技术拆分臃肿的单体应用，导致软件架构进一步复杂化，难以维护，使得原本具有优势的微架构出现一些问题。

一个设计良好的架构会变成人人嫌弃的架构的一些理由：
* 架构的设计不符合演进的需求
* 开始设计时，架构就不合理
* 架构本身是合理的，后继的开发者能力不足
* 架构本身是合理的，然而开发的过程中走歪了。

“走歪了的流程”，是导致“微”害架构的元凶。在开发能力完备的情况下，架构走向不合理的原因是KPI。有KPI导向的系统架构设计，必然会出现一定的不合理性。
* “我们的竞争对手采用了微服务架构，你看看我们有没有办法也用这个架构？”
* “隔壁开发小组的团队使用了微前端架构，我们也上这个架构吧？”
* “小李啊，听说最近微服务很火啊，你看能不能用到我们的项目上？”
从这种角度来看，架构是不是最好的不重要，重要的是大家都满意。只有领导满意，才可以涨工资；只有被团队采用，才可以向外宣传，吸引新成员。

#### 1. 微架构
与微架构开发类似的有：
* 后端拆分。其典型的形式是微服务
* App拆分。App存在多种容器，有插件化、组件化、小程序等不同的方案。由于一个大型组织的App所承载的功能相当丰富，其有可能拥有不逊色于操作系统的代码量。要实现跨团队共同在一个代码库开发，并不是一件容易的事。因此采用一个App平台的方案，让不同部分的业务可以在上面运行，是一个更符合组织架构的开发模式。
* 前端拆分。大规模前端应用的开发历史要比App短得多，但是也出现了一系列的拆分方案：前端微服务化、微应用化、微件化，等等。前端走向微前端架构的原因，除了庞大的单体应用，还有一部分是要聚合旧的遗留应用。我们希望旧的遗留应用，能不经修改或者少量的修改，就可以嵌入新的系统中。

#### 2. 架构的演进
《Linux/Unix设计思想》一书中提到的三个系统：
* (1) 在背水一战的情况下，人类设计出了第一个系统
* (2) 专家们在第一个系统的基础上，做出了伟大而臃肿的第二个系统
* (3) 受累于第二个系统的人，设计出了第三个系统

大部分组织会意识到三个系统的存在。于是，在Idea设计一个新系统时，采用了第三个系统的架构，然后出错了——因为他们缺少专家。这里的专家并非单纯指技术方面的专家，而是技术专家+业务专家。架构在底层是由技术实现的，而在顶层则是由业务代码实现的。

#### 3. 微架构带来的问题
在不同的微架构领域里，有着不同的问题。在考察是否使用某项技术的时候，我们的第一答案是：“直接使用这种架构，具体遇到什么问题再解决”。

**后端：微服务到应用**

后端实施微服务的一些问题：
* 代码架构。在不同的组织之间采用微服务架构，对于相互之间是由好处的。但在一个小型的内部组织里，掌握代码独立的微服务数量就值得考虑了——既然不需要和别人沟通，为什么需要在十多个repo间切换？
* 部署流程。微服务讲究独立开发、独立部署，如果一个微服务不能独立部署，那么部署就变成一件痛苦的事情。如果在一次release计划里，我们需要同时上线十几个服务，就变得...

在这种情况下，这些开发者就在考虑，采用微服务架构是否值得。实际上问题的本质可能是，是否有独立拆分微服务的必要？或者采取集成构建的方式，在开发和构建时来独立两个应用，在部署时只部署一个应用。

**客户端：插件化、组件化**

App可以分为插件化和组件化两种方式。插件化是集成构建后完成的APK包，而组件化(Module)则是集成构建后的模块(Lib)。Web前端的拆分则可以是微前端、微应用和跨框架组件化的几种形式。

业务的价值往往以大前端的形式呈现，因此移动应用在代码的拆分上，往往比后端容易。不论采用动态加载、UI跳转、路由或者其他方式，都要考虑如何来拆分代码。

于是，遇到了一下问题：
* 一个简单的业务，是否有必要成为一个简单的服务？
* 当我们有一系列简单的功能时，它们真的要独立运行？它们是否有必要称为多个简单的组件？它们不能是一个组件来接受多个参数吗？

面对这些问题，我们可以采取合适的代码拆分策略，以便在未来合适的时候进行拆分。限制我们这么做的主要原因是：后期拆分的时候会面临巨大的挑战。

#### 4. 解决方式：可拆分式微架构
要合并多个后端服务，就要统一技术栈。

对前端来说，只需要保证可以成功构建即可。如微应用化就是一种构建时集成的方式。

这种方式并不违反微服务的一系列原则，服务自治、专注的服务等。如果我们修改的代码在某一个特定的服务里，那么我们只需要将它们拆分出来独立部署。同样的道理适用于App插件化和前端微应用化。如果没有规范化的开发流程，架构之间可能会出现进一步地耦合。（~~不是很明白，难道是说前端毕竟是静态文件，能独立部署和组合即可？）









